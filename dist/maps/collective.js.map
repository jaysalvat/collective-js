{"version":3,"sources":["collective.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../collective.js","sourcesContent":["/* global define */\n\n(function (context, factory) {\n    'use strict';\n    // UMD\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else {\n        context.Collective = factory();\n    }\n})(this, function () {\n    'use strict';\n\n    /**\n     * Collective Constructor\n     * @constructor\n     * @param {Mixed} collection [array, object, function, Collective instance ]\n     */\n    var Collective = function (input) {\n        if (!(this instanceof Collective)) {\n            return new Collective(input);\n        }\n\n        if (input instanceof Function) {\n            input = input();\n        }\n\n        /**\n         * Array of elements use by the collection\n         * @type {Array}\n         */\n        this.collection = convert(input);\n        this.length = this.collection.length;\n\n        /**\n         * Object of events and callbacks\n         * @type {Object}\n         */\n        this.events = {};\n    };\n\n    /**\n     * Get the value of a nested property by a dot.notation path\n     * @param  {Object} object  Object to search in\n     * @param  {String} path    Dot.notation string ex. key1.key2[0].key3\n     * @return {Mixed}          Value\n     */\n    Collective.path = function (object, path) {\n        path = (path || '').split('.');\n\n        return path.reduce(function (value, key) {\n            var index, matches = /(.*?)\\[(.*?)\\]$/g.exec(key);\n\n            if (matches) {\n                key = matches[1];\n                index = matches[2];\n            }\n\n            try {\n                return index !== undefined ? value[key][index] : value[key];\n            } catch(e) {\n                return;\n            }\n        }, object);\n    };\n\n    /**\n     * Get an nested object build from a dot.notation path\n     * @param  {String}  path      Dot.notation path\n     * @param  {Mixed}   value     Value of the finale property\n     * @param  {boolean} skipFirst Skip first level of object\n     * @return {Object}\n     */\n    Collective.object = function (path, value, skipFirst) {\n        var obj, buffer, key;\n\n        path = (path || '').split('.');\n\n        if (skipFirst) {\n            path.shift();\n\n            if (!path.length) {\n                return value;\n            }\n        }\n\n        while (path.length) {\n            key = path.pop();\n            obj = {};\n            obj[key] = or(buffer, value);\n            buffer = obj;\n        }\n\n        return obj;\n    };\n\n    /**\n     * Convert an object to a dot.notation path\n     * @param  {Object} obj     Object\n     * @param  {String} [path]  Path to append\n     * @return {String}\n     */\n    Collective.dot = function (obj, path) {\n        path = path || [];\n\n        Object.keys(obj).forEach(function (key) {\n            path.push(key);\n\n            if (typeof obj[key] === 'object') {\n                return Collective.dot(obj[key], path);\n            }\n        });\n\n        return path.join('.');\n    };\n\n    /**\n     * Extend/Clone object\n     * @param  {Object} target    Target Object\n     * @param  {Object} ...source Source Objects\n     * @return {Object}\n     */\n    Collective.extend = function (target) {\n        var object = Object(target);\n\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n\n            if (source !== null) {\n                for (var key in source) {\n                    if (Object.prototype.hasOwnProperty.call(source, key)) {\n                        object[key] = source[key];\n                    }\n                }\n            }\n        }\n\n        return object;\n    };\n\n    /**\n     * Prototype methods\n     */\n    Collective.prototype = {\n        /**\n         * Get the array of data\n         * @return {Array}\n         */\n        all: function () {\n            return this.collection;\n        },\n\n        /**\n         * Set an element by its index\n         * @param  {Number}         Index\n         * @param  {Object}         Element\n         * @return {Collecttive}    Collective collection\n         */\n        set: function (index, elmt) {\n            var data = this.collection.slice();\n\n            elmt = convert(elmt);\n\n            data[index] = elmt;\n\n            var clone = this.clone(data);\n\n            this.trigger('update', [ elmt ], clone);\n\n            return clone;\n        },\n\n        /**\n         * Get an element by its index\n         * Get an empty element if empty\n         * @param  {Number}     Index\n         * @return {Object}     Object of the collection\n         */\n        get: function (index) {\n            return this.collection[index] || {};\n        },\n\n        /**\n         * Get the first element of the collection\n         * Get an empty object if empty\n         * @return {Object}         Object of the collection\n         */\n        first: function () {\n            return this.get(0);\n        },\n\n        /**\n         * Get the last element of the collection\n         * Get an empty element if empty\n         * @return {Object}         Object of the collection\n         */\n        last: function () {\n            return this.get(this.collection.length - 1);\n        },\n\n        /**\n         * Get the value of a property from the 1st element of the collection\n         * @param  {String} key     Key of a collection object property\n         * @return {Mixed}          Value of the property\n         */\n        prop: function (key) {\n            return this.get(0)[key];\n        },\n\n        /**\n         * Get the first object of the collection matching search criteria\n         * Get an empty object if empty\n         * @param  {Mixed} queries  Object or array of objects of criteria\n         * @return {Object}         Object of the collection\n         */\n        find: function (queries) {\n            return this.where(queries).first();\n        },\n\n        /**\n         * Get a collection of objects with some properties only\n         * @param  {Array} fields   Array of property names\n         * @return {Collective}     Collective collection\n         */\n        fields: function (keys) {\n            var data = [];\n\n            keys = forceArray(keys);\n\n            this.collection.forEach(function (elmt) {\n                var obj = {};\n\n                keys.forEach(function (key) {\n                    obj[key] = or(elmt[key], null);\n                });\n\n                data.push(obj);\n            });\n\n            var clone = this.clone(data);\n\n            if (!compare(data, this.collection)) {\n                this.trigger('update', data, clone);\n            }\n\n            return clone;\n        },\n\n        /**\n         * Get an array or a key/value object of some object properties\n         * @param  {Mixed}  keys1    Property or array of properties\n         * @param  {Mixed}  keys2    Property or array of properties\n         * @param  {String} format1  Format string to format response Ex. {0} [{1}]\n         * @param  {String} format2  Format string to format response\n         * @return {Mixed}           Array or Object\n         */\n        pluck: function (keys1, keys2, format1, format2) {\n            var array = [], obj = {}, pairs = !!keys2;\n\n            keys1 = forceArray(keys1);\n            keys2 = forceArray(keys2);\n            format1 = or(format1, '{0}');\n            format2 = or(format2, '{0}');\n\n            this.collection.forEach(function (elmt) {\n                var formated1 = format1,\n                    formated2 = format2;\n\n                keys1.forEach(function (key, i) {\n                    var value = Collective.path(elmt, key) || '';\n                    formated1 = formated1.replace(new RegExp('\\\\{' + i + '\\\\}', 'g'), value);\n                });\n\n                keys2.forEach(function (key, i) {\n                    var value = Collective.path(elmt, key) || '';\n                    formated2 = formated2.replace(new RegExp('\\\\{' + i + '\\\\}', 'g'), value);\n                });\n\n                array.push(formated1);\n                obj[formated1] = formated2;\n            });\n\n            return pairs ? obj : array;\n        },\n\n        /**\n         * Sort the collection\n         * @param  {Object} query   Object of properties to sort with 1: ASC, -1: DESC\n         * @return {Collective}     Collective collection\n         */\n        sort: function (query) {\n            var data = this.collection.slice();\n\n            if (typeof query === 'function') {\n                data = data.sort(query);\n            } else {\n                data = data.sort(function (elmt1, elmt2) {\n                    var i, key, direction, value1, value2, keys = Object.keys(query);\n\n                    for (i = 0; i < keys.length; i++) {\n                        key = keys[i];\n                        direction = query[key];\n                        value1 = Collective.path(elmt1, key);\n                        value2 = Collective.path(elmt2, key);\n\n                        if (!direction) {\n                            direction = -1;\n                        }\n\n                        if (value1 === undefined) {\n                            return 0;\n                        }\n                        if (value1 < value2) {\n                            return direction * -1;\n                        }\n                        if (value1 > value2) {\n                            return direction;\n                        }\n                    }\n\n                    return 0;\n                });\n            }\n\n            var clone = this.clone(data);\n\n            if (!compare(data, this.collection)) {\n                this.trigger('sort', query, clone);\n            }\n\n            return clone;\n        },\n\n        /**\n         * Get a collection with uniq elements only\n         * @return {Collective}     Collective collection\n         */\n        uniq: function () {\n            var self = this, data;\n\n            data = this.collection.filter(function (elmt, index) {\n                return self.index(elmt) === index;\n            });\n\n            return this.clone(data);\n        },\n\n        /**\n         * Filter the collection matching search criteria\n         * @param  {Mixed}  queries   Object or array of objects of criteria\n         * @param  {Object} settings  Settings [ exclude, indexed ]\n         * @return {Mixed}            Collective collection or array of indexes\n         */\n        where: function (queries, settings) {\n            var indexes = [],\n                data = this.collection.slice();\n\n            settings = settings || {};\n\n            queries = forceArray(queries);\n\n            data = data.filter(function (elmt, index) {\n                var q, found = settings.exclude;\n\n                // Loop query elements\n                for (q = 0; q < queries.length; q++) {\n                    var i,\n                        query = queries[q],\n                        queryKeys = Object.keys(query),\n                        keep = !settings.exclude;\n\n                    // If index\n                    if (Number.isInteger(query)) {\n                         if (query !== index) {\n                            keep = settings.exclude;\n                            break;\n                         }\n                    // If object\n                    } else {\n                        // Loop object properties\n                        for (i = 0; i < queryKeys.length; i++) {\n                            var queryKey   = queryKeys[i],\n                                queryValue = query[queryKey],\n                                elmtValue  = Collective.path(elmt, queryKey);\n\n                            // If function\n                            if (typeof queryValue === 'function') {\n                                if (!queryValue.call(this, elmtValue, queryKey)) {\n                                    keep = settings.exclude;\n                                }\n                                break;\n                            // If not function\n                            } else if (queryValue === undefined || elmtValue !== queryValue) {\n                                keep = settings.exclude;\n                                break;\n                            }\n                        }\n                    }\n\n                    found = keep;\n\n                    // Store indexes if not in `exclude mode`\n                    if (keep !== settings.exclude) {\n                        if (indexes.indexOf(index) < 0) {\n                            indexes.push(index);\n                        }\n                        break;\n                    }\n                }\n\n                return found;\n            });\n\n            // If indexes mode, we return an array of indexes\n            if (settings.indexes) {\n                return indexes;\n            }\n\n            return this.clone(data);\n        },\n\n        /**\n         * Add elements to the collection\n         * @param {String}  method   Name of JS method to use\n         * @param {Mixed}   elmts    Element or array of elements to add\n         * @param {Number}  [index]  Index for before/after method\n         * @return {Collective}      Collective collection\n         */\n        add: function (method, elmts, index) {\n            var data = this.collection.slice();\n\n            elmts = convert(elmts, true);\n\n            elmts.forEach(function (elmt) {\n                if (method === 'splice') {\n                    data.splice(index, 0, elmt);\n                } else {\n                    data[method](elmt);\n                }\n            });\n\n            var clone = this.clone(data);\n\n            this.trigger('add', elmts, clone);\n\n            return clone;\n        },\n\n        /**\n         * Add elements at the begginning of the collection\n         * @param  {Mixed} elmts   Element or array of elements to add\n         * @return {Collective}    Collective collection\n         */\n        append: function (elmts) {\n            return this.add('push', elmts);\n        },\n\n        /**\n         * Add elements at the end of the collection\n         * @param  {Mixed} elmts   Element or array of elements to add\n         * @return {Collective}    Collective collection\n         */\n        prepend: function (elmts) {\n            return this.add('unshift', elmts);\n        },\n\n        /**\n         * Add elements before an element of the collection matching search criteria\n         * @param  {Object} query  Object of criteria\n         * @param  {Mixed}  elmts  Element or array of elements to add\n         * @return {Mixed}         Collective collection\n         */\n        before: function (query, elmts) {\n            return this.add('splice', elmts, this.index(query));\n        },\n\n        /**\n         * Add elements after an element of the collection matching search criteria\n         * @param  {Object} query   Object of criteria\n         * @param  {Mixed}  elmts   Element or array of elements to add\n         * @return {Collective}     Collective collection\n         */\n        after: function (query, elmts) {\n            return this.add('splice', elmts, this.index(query) + 1);\n        },\n\n        /**\n         * Update the elements of the collection matching the search criteria\n         * @param  {Mixed}   queries    Object or array of objects of criteria\n         * @param  {Object}  newData    Object of data to update\n         * @param  {boolean} [replace]  Replace/Merge mode\n         * @return {Collective}         Collective collection\n         */\n        update: function (queries, newData, replace) {\n            var self = this,\n                data = this.collection.slice(),\n                updated = [];\n\n            //  If no query, update all the elements in the collection\n            if (!newData || newData === true) {\n                newData = queries;\n\n                this.collection.forEach(function (elmt, index) {\n                    self.update(index, newData, replace);\n                });\n            // Update the query selected elements\n            } else {\n                this.where(queries, { indexes: true }).forEach(function (index) {\n                    if (replace) {\n                        data[index] = newData;\n                    } else {\n                        Collective.extend(data[index], newData);\n                    }\n\n                    updated.push(data[index]);\n                });\n            }\n\n            var clone = this.clone(data);\n\n            if (updated.length) {\n                this.trigger('update', updated, clone);\n            }\n\n            return clone;\n        },\n\n        /**\n         * Replace the elements of the collection matching the search criteria\n         * @param  {Mixed}   queries    Object or array of objects of criteria\n         * @param  {Object}  newData    Object of data to update\n         * @return {Collective}         Collective collection\n         */\n        replace: function (queries, newData) {\n            return this.update(queries, newData, true);\n        },\n\n        /**\n         * Get a collection without the elements matching the search criteria\n         * @param  {Mixed}  queries   Object or array of objects of criteria\n         * @return {Collective}       Collective collection\n         */\n        remove: function (queries) {\n            var removed = this.where(queries).all(),\n                clone   = this.where(queries, { exclude: true });\n\n            if (removed.length) {\n                this.trigger('remove', removed, clone);\n            }\n\n            return clone;\n        },\n\n        /**\n         * Add an event callback when collection changes\n         * @param  {String}   event     Name of the event [ change, add, remove, fields, update]\n         * @param  {Function} callback  Function to call\n         * @return {Collective}         Collective collection\n         */\n        on: function (event, callback) {\n            this.events[event] = this.events[event] || [];\n            this.events[event].push(callback);\n\n            return this;\n        },\n\n        /**\n         * Remove an event callback\n         * @param  {String}   event     Name of the event [ change, add, remove, fields, update]\n         * @param  {Function} callback  Function to remove\n         * @return {Collective}         Collective collection\n         */\n        off: function (event, callback) {\n            this.events[event] = (this.events[event] || []).filter(function (value) {\n                return value !== callback;\n            });\n\n            return this;\n        },\n\n        /**\n         * Trigger the event callbacks\n         * @param  {String} event     Name of the event to trigger\n         * @param  {Mixed}  data      Data to pass to the called function\n         * @param  {Object} clone     Context for function call\n         * @return {Collective}       Collective collection\n         */\n        trigger: function (event, data, context) {\n            var callbacks1 = this.events.change || [], // Change event\n                callbacks2 = this.events[event] || [], // X event\n                callbacks  = callbacks1.concat(callbacks2);\n\n            context = context || this;\n\n            callbacks.forEach(function (callback) {\n                callback.call(context, data, event);\n            });\n\n            return context;\n        },\n\n        /**\n         * Clone a Collective collection\n         * @param  {Array} data     Array of elements to copy in the new collection\n         * @return {Collective}     Collective collection\n         */\n        clone: function (data) {\n            var copy = Object.create(this);\n            copy.collection = data ? data.slice() : this.collection.slice();\n            copy.length = copy.collection.length;\n\n            return copy;\n        },\n\n        /**\n         * Transfer values to a new element structure\n         * @param  {Object} mapping    Object of properties to transfer\n         * @return {Collective}        Collective collection\n         */\n        transfer: function (mapping) {\n            var data = [];\n\n            function mapIt (mapping, elmt) {\n                var buffer = {};\n\n                Object.keys(mapping).forEach(function (key) {\n                    var shortKey = key.split('.')[0],\n                        value;\n\n                    if (typeof mapping[key] === 'object') {\n                        value = mapIt(mapping[key], elmt);\n                    }\n                    else if (typeof mapping[key] === 'string') {\n                        value = Collective.path(elmt, mapping[key]);\n                    }\n\n                    buffer[shortKey] = Collective.object(key, value, true);\n                });\n\n                return buffer;\n            }\n\n            this.collection.forEach(function (elmt) {\n                data.push(mapIt(mapping, elmt));\n            });\n\n            var clone = this.clone(data);\n\n            if (!compare(data, this.collection)) {\n                this.trigger('update', data, clone);\n            }\n\n            return clone;\n        },\n\n        /**\n         * Split an array into chunks\n         * @param  {Number} number  Number of elements per chunk\n         * @return {Array}          Array of chunks\n         */\n        chunk: function (number) {\n            var i, total, chunks = [];\n\n            number = number || 5;\n            total = Math.ceil(this.collection.length / number);\n\n            for (i = 0; i < total; i++) {\n                chunks.push(this.collection.slice(i * number, i * number + number));\n            }\n\n            return chunks;\n        },\n\n\n        /**\n         * Get index of the first object of the collection matching search criteria\n         * @param  {Mixed} queries  Object or array of objects of criteria\n         * @return {Mixed}          Index of the object or false\n         */\n        index: function (queries) {\n            return this.where(queries, { indexes: true })[0];\n        },\n\n        /**\n         * Get index of the first found object in the collection similar to another object\n         * @param  {Object}  obj1      Object to compare\n         * @param  {Number}  [start]   Index to start with\n         * @param  {boolean} [last]    last index\n         * @return {Number}            Index found or -1\n         */\n        indexOf: function (elmt, start, last) {\n            var i, index = -1, len = this.collection.length;\n\n            start =  start || 0;\n\n            for (i = start; i < len; i++) {\n                var x, found = true,\n                    j = last ? len - i + start - 1 : i,\n                    elmt2     = this.collection[j],\n                    elmtKeys  = Object.keys(elmt),\n                    elmt2Keys = Object.keys(elmt2);\n\n                for (x = 0; x < elmtKeys.length; x++) {\n                    if (elmt[elmtKeys[x]] !== elmt2[elmtKeys[x]]) {\n                        found = false;\n                        break;\n                    }\n                }\n\n                for (x = 0; x < elmt2Keys.length; x++) {\n                    if (elmt[elmt2Keys[x]] !== elmt2[elmt2Keys[x]]) {\n                        found = false;\n                        break;\n                    }\n                }\n\n                if (found) {\n                    index = j;\n                    break;\n                }\n            }\n\n            return index;\n        },\n\n        /**\n         * Get index of the last found object in the collection similar to another object\n         * @param  {Object}  elmt      Element to compare\n         * @param  {Number}  [start]   Index to start with\n         * @return {Number}            Index found or -1\n         */\n        lastIndexOf: function (elmt, start) {\n            return this.indexOf(elmt, start, true);\n        },\n\n        /**\n         * Determine whether an array includes an element\n         * @param  {Object}  elmt      Element to compare\n         * @return {boolean}\n         */\n        includes: function (elmt) {\n            return this.indexOf(elmt) > -1;\n        },\n\n        /**\n         * Join an element property into a string.\n         * @param  {String} key       Property key\n         * @param  {String} separator Separator string\n         * @return {String}           Elements joined in a string\n         */\n        join: function (key, separator) {\n            return this.pluck(key).join(separator);\n        }\n    };\n\n    /**\n     * Proxy some native Array methods to modify the collection\n     * @return {Collective}     Collective collection\n     */\n    [ 'forEach', 'filter', 'slice', 'concat', 'map', 'reverse' ].forEach(function (fn) {\n        Collective.prototype[fn] = function () {\n            var data = this.collection[fn].apply(this.collection, [].slice.call(arguments));\n\n            return this.clone(data);\n        };\n    });\n\n    /**\n     * Proxy some native Array methods with native behaviors\n     * @return {Mixed}\n     */\n    [ 'pop', 'shift', 'push', 'unshift', 'every', 'some', 'reduce', 'splice', 'fill' ].forEach(function (fn) {\n        Collective.prototype[fn] = function () {\n            var value = this.collection[fn].apply(this.collection, [].slice.call(arguments));\n\n            this.length = this.collection.length;\n\n            return value;\n        };\n    });\n\n    /**\n     * Some Helpers\n     */\n\n    /**\n     * Return value2 if value1 is undefined\n     * @param  {Mixed} value1  Value to check\n     * @param  {Mixed} value2  Value to return\n     * @return {Mixed}         Value1 or Value2\n     */\n    function or (value1, value2) {\n        return value1 === undefined ? value2 : value1;\n    }\n\n    /**\n     * Return an Array with the value if not already an Array\n     * @param  {Mixed} elmts\n     * @return {Array}\n     */\n    function forceArray (elmts) {\n        return Array.isArray(elmts) ? elmts : [ elmts ];\n    }\n\n    /**\n     * Flatten and compare 2 values, Array or Object to check if similare\n     * @param  {Mixed} input1\n     * @param  {Mixed} input2\n     * @return {Boolean}\n     */\n    function compare (input1, input2) {\n        return JSON.stringify(input1) === JSON.stringify(input2);\n    }\n\n    /**\n     * Convert elements into a what Collective expects for its collection\n     * Throw an Error if the collection is not valid (Array of Objects)\n     * @param  {Mixed}   elmts       Array or OBject\n     * @param  {Boolean} mustBeArray Force to be an Array\n     * @return [Mixed]\n     */\n    function convert (elmts, mustBeArray) {\n        elmts = JSON.parse(JSON.stringify(elmts));\n        elmts = or(elmts.collection, elmts);\n        elmts = mustBeArray ? forceArray(elmts) : elmts;\n        isCollection(elmts, true);\n\n        return elmts;\n    }\n\n    /**\n     * Check if the collection is a valid Array of Objects\n     * @param  {Array}    collection     Collection\n     * @param  {Boolean}  throwError     Throw an error instead of returning false\n     * @return [{Boolean}]\n     */\n    function isCollection (collection, throwError) {\n        var isOk = forceArray(collection).every(function (element) {\n            return {}.toString.call(element) === \"[object Object]\";\n        });\n\n        if (!isOk && throwError) {\n            throw new Error('Collective only accepts Array/Objects.');\n        }\n\n        return isOk;\n    }\n\n    return Collective;\n});\n"]}