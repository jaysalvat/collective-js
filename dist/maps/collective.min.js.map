{"version":3,"sources":["maps/collective.js"],"names":["context","factory","module","exports","define","amd","Collective","this","or","value1","value2","undefined","forceArray","elmts","Array","isArray","compare","input1","input2","JSON","stringify","convert","mustBeArray","parse","collection","isCollection","throwError","isOk","every","element","toString","call","Error","input","Function","length","events","path","object","split","reduce","value","key","index","matches","exec","e","skipFirst","obj","buffer","shift","pop","dot","Object","keys","forEach","push","join","extend","target","i","arguments","source","prototype","hasOwnProperty","all","set","elmt","data","slice","clone","trigger","get","first","last","prop","find","queries","where","fields","pluck","keys1","keys2","format1","format2","array","pairs","formated1","formated2","replace","RegExp","sort","query","elmt1","elmt2","direction","uniq","self","filter","settings","indexes","q","found","exclude","queryKeys","keep","Number","isInteger","queryKey","queryValue","elmtValue","indexOf","add","method","splice","append","prepend","before","after","update","newData","updated","remove","removed","on","event","callback","off","callbacks1","change","callbacks2","callbacks","concat","copy","create","transfer","mapping","mapIt","shortKey","chunk","number","total","chunks","Math","ceil","start","len","x","j","elmtKeys","elmt2Keys","lastIndexOf","includes","separator","fn","apply"],"mappings":"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","file":"../collective.min.js","sourcesContent":["/* global define */\n\n(function (context, factory) {\n    'use strict';\n    // UMD\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else {\n        context.Collective = factory();\n    }\n})(this, function () {\n    'use strict';\n\n    /**\n     * Collective Constructor\n     * @constructor\n     * @param {Mixed} collection [array, object, function, Collective instance ]\n     */\n    var Collective = function (input) {\n        if (!(this instanceof Collective)) {\n            return new Collective(input);\n        }\n\n        if (input instanceof Function) {\n            input = input();\n        }\n\n        /**\n         * Array of elements use by the collection\n         * @type {Array}\n         */\n        this.collection = convert(input);\n        this.length = this.collection.length;\n\n        /**\n         * Object of events and callbacks\n         * @type {Object}\n         */\n        this.events = {};\n    };\n\n    /**\n     * Get the value of a nested property by a dot.notation path\n     * @param  {Object} object  Object to search in\n     * @param  {String} path    Dot.notation string ex. key1.key2[0].key3\n     * @return {Mixed}          Value\n     */\n    Collective.path = function (object, path) {\n        path = (path || '').split('.');\n\n        return path.reduce(function (value, key) {\n            var index, matches = /(.*?)\\[(.*?)\\]$/g.exec(key);\n\n            if (matches) {\n                key = matches[1];\n                index = matches[2];\n            }\n\n            try {\n                return index !== undefined ? value[key][index] : value[key];\n            } catch(e) {\n                return;\n            }\n        }, object);\n    };\n\n    /**\n     * Get an nested object build from a dot.notation path\n     * @param  {String}  path      Dot.notation path\n     * @param  {Mixed}   value     Value of the finale property\n     * @param  {boolean} skipFirst Skip first level of object\n     * @return {Object}\n     */\n    Collective.object = function (path, value, skipFirst) {\n        var obj, buffer, key;\n\n        path = (path || '').split('.');\n\n        if (skipFirst) {\n            path.shift();\n\n            if (!path.length) {\n                return value;\n            }\n        }\n\n        while (path.length) {\n            key = path.pop();\n            obj = {};\n            obj[key] = or(buffer, value);\n            buffer = obj;\n        }\n\n        return obj;\n    };\n\n    /**\n     * Convert an object to a dot.notation path\n     * @param  {Object} obj     Object\n     * @param  {String} [path]  Path to append\n     * @return {String}\n     */\n    Collective.dot = function (obj, path) {\n        path = path || [];\n\n        Object.keys(obj).forEach(function (key) {\n            path.push(key);\n\n            if (typeof obj[key] === 'object') {\n                return Collective.dot(obj[key], path);\n            }\n        });\n\n        return path.join('.');\n    };\n\n    /**\n     * Extend/Clone object\n     * @param  {Object} target    Target Object\n     * @param  {Object} ...source Source Objects\n     * @return {Object}\n     */\n    Collective.extend = function (target) {\n        var object = Object(target);\n\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n\n            if (source !== null) {\n                for (var key in source) {\n                    if (Object.prototype.hasOwnProperty.call(source, key)) {\n                        object[key] = source[key];\n                    }\n                }\n            }\n        }\n\n        return object;\n    };\n\n    /**\n     * Prototype methods\n     */\n    Collective.prototype = {\n        /**\n         * Get the array of data\n         * @return {Array}\n         */\n        all: function () {\n            return this.collection;\n        },\n\n        /**\n         * Set an element by its index\n         * @param  {Number}         Index\n         * @param  {Object}         Element\n         * @return {Collecttive}    Collective collection\n         */\n        set: function (index, elmt) {\n            var data = this.collection.slice();\n\n            elmt = convert(elmt);\n\n            data[index] = elmt;\n\n            var clone = this.clone(data);\n\n            this.trigger('update', [ elmt ], clone);\n\n            return clone;\n        },\n\n        /**\n         * Get an element by its index\n         * Get an empty element if empty\n         * @param  {Number}     Index\n         * @return {Object}     Object of the collection\n         */\n        get: function (index) {\n            return this.collection[index] || {};\n        },\n\n        /**\n         * Get the first element of the collection\n         * Get an empty object if empty\n         * @return {Object}         Object of the collection\n         */\n        first: function () {\n            return this.get(0);\n        },\n\n        /**\n         * Get the last element of the collection\n         * Get an empty element if empty\n         * @return {Object}         Object of the collection\n         */\n        last: function () {\n            return this.get(this.collection.length - 1);\n        },\n\n        /**\n         * Get the value of a property from the 1st element of the collection\n         * @param  {String} key     Key of a collection object property\n         * @return {Mixed}          Value of the property\n         */\n        prop: function (key) {\n            return this.get(0)[key];\n        },\n\n        /**\n         * Get the first object of the collection matching search criteria\n         * Get an empty object if empty\n         * @param  {Mixed} queries  Object or array of objects of criteria\n         * @return {Object}         Object of the collection\n         */\n        find: function (queries) {\n            return this.where(queries).first();\n        },\n\n        /**\n         * Get a collection of objects with some properties only\n         * @param  {Array} fields   Array of property names\n         * @return {Collective}     Collective collection\n         */\n        fields: function (keys) {\n            var data = [];\n\n            keys = forceArray(keys);\n\n            this.collection.forEach(function (elmt) {\n                var obj = {};\n\n                keys.forEach(function (key) {\n                    obj[key] = or(elmt[key], null);\n                });\n\n                data.push(obj);\n            });\n\n            var clone = this.clone(data);\n\n            if (!compare(data, this.collection)) {\n                this.trigger('update', data, clone);\n            }\n\n            return clone;\n        },\n\n        /**\n         * Get an array or a key/value object of some object properties\n         * @param  {Mixed}  keys1    Property or array of properties\n         * @param  {Mixed}  keys2    Property or array of properties\n         * @param  {String} format1  Format string to format response Ex. {0} [{1}]\n         * @param  {String} format2  Format string to format response\n         * @return {Mixed}           Array or Object\n         */\n        pluck: function (keys1, keys2, format1, format2) {\n            var array = [], obj = {}, pairs = !!keys2;\n\n            keys1 = forceArray(keys1);\n            keys2 = forceArray(keys2);\n            format1 = or(format1, '{0}');\n            format2 = or(format2, '{0}');\n\n            this.collection.forEach(function (elmt) {\n                var formated1 = format1,\n                    formated2 = format2;\n\n                keys1.forEach(function (key, i) {\n                    var value = Collective.path(elmt, key) || '';\n                    formated1 = formated1.replace(new RegExp('\\\\{' + i + '\\\\}', 'g'), value);\n                });\n\n                keys2.forEach(function (key, i) {\n                    var value = Collective.path(elmt, key) || '';\n                    formated2 = formated2.replace(new RegExp('\\\\{' + i + '\\\\}', 'g'), value);\n                });\n\n                array.push(formated1);\n                obj[formated1] = formated2;\n            });\n\n            return pairs ? obj : array;\n        },\n\n        /**\n         * Sort the collection\n         * @param  {Object} query   Object of properties to sort with 1: ASC, -1: DESC\n         * @return {Collective}     Collective collection\n         */\n        sort: function (query) {\n            var data = this.collection.slice();\n\n            if (typeof query === 'function') {\n                data = data.sort(query);\n            } else {\n                data = data.sort(function (elmt1, elmt2) {\n                    var i, key, direction, value1, value2, keys = Object.keys(query);\n\n                    for (i = 0; i < keys.length; i++) {\n                        key = keys[i];\n                        direction = query[key];\n                        value1 = Collective.path(elmt1, key);\n                        value2 = Collective.path(elmt2, key);\n\n                        if (!direction) {\n                            direction = -1;\n                        }\n\n                        if (value1 === undefined) {\n                            return 0;\n                        }\n                        if (value1 < value2) {\n                            return direction * -1;\n                        }\n                        if (value1 > value2) {\n                            return direction;\n                        }\n                    }\n\n                    return 0;\n                });\n            }\n\n            var clone = this.clone(data);\n\n            if (!compare(data, this.collection)) {\n                this.trigger('sort', query, clone);\n            }\n\n            return clone;\n        },\n\n        /**\n         * Get a collection with uniq elements only\n         * @return {Collective}     Collective collection\n         */\n        uniq: function () {\n            var self = this, data;\n\n            data = this.collection.filter(function (elmt, index) {\n                return self.index(elmt) === index;\n            });\n\n            return this.clone(data);\n        },\n\n        /**\n         * Filter the collection matching search criteria\n         * @param  {Mixed}  queries   Object or array of objects of criteria\n         * @param  {Object} settings  Settings [ exclude, indexed ]\n         * @return {Mixed}            Collective collection or array of indexes\n         */\n        where: function (queries, settings) {\n            var indexes = [],\n                data = this.collection.slice();\n\n            settings = settings || {};\n\n            queries = forceArray(queries);\n\n            data = data.filter(function (elmt, index) {\n                var q, found = settings.exclude;\n\n                // Loop query elements\n                for (q = 0; q < queries.length; q++) {\n                    var i,\n                        query = queries[q],\n                        queryKeys = Object.keys(query),\n                        keep = !settings.exclude;\n\n                    // If index\n                    if (Number.isInteger(query)) {\n                         if (query !== index) {\n                            keep = settings.exclude;\n                            break;\n                         }\n                    // If object\n                    } else {\n                        // Loop object properties\n                        for (i = 0; i < queryKeys.length; i++) {\n                            var queryKey   = queryKeys[i],\n                                queryValue = query[queryKey],\n                                elmtValue  = Collective.path(elmt, queryKey);\n\n                            // If function\n                            if (typeof queryValue === 'function') {\n                                if (!queryValue.call(this, elmtValue, queryKey)) {\n                                    keep = settings.exclude;\n                                }\n                                break;\n                            // If not function\n                            } else if (queryValue === undefined || elmtValue !== queryValue) {\n                                keep = settings.exclude;\n                                break;\n                            }\n                        }\n                    }\n\n                    found = keep;\n\n                    // Store indexes if not in `exclude mode`\n                    if (keep !== settings.exclude) {\n                        if (indexes.indexOf(index) < 0) {\n                            indexes.push(index);\n                        }\n                        break;\n                    }\n                }\n\n                return found;\n            });\n\n            // If indexes mode, we return an array of indexes\n            if (settings.indexes) {\n                return indexes;\n            }\n\n            return this.clone(data);\n        },\n\n        /**\n         * Add elements to the collection\n         * @param {String}  method   Name of JS method to use\n         * @param {Mixed}   elmts    Element or array of elements to add\n         * @param {Number}  [index]  Index for before/after method\n         * @return {Collective}      Collective collection\n         */\n        add: function (method, elmts, index) {\n            var data = this.collection.slice();\n\n            elmts = convert(elmts, true);\n\n            elmts.forEach(function (elmt) {\n                if (method === 'splice') {\n                    data.splice(index, 0, elmt);\n                } else {\n                    data[method](elmt);\n                }\n            });\n\n            var clone = this.clone(data);\n\n            this.trigger('add', elmts, clone);\n\n            return clone;\n        },\n\n        /**\n         * Add elements at the begginning of the collection\n         * @param  {Mixed} elmts   Element or array of elements to add\n         * @return {Collective}    Collective collection\n         */\n        append: function (elmts) {\n            return this.add('push', elmts);\n        },\n\n        /**\n         * Add elements at the end of the collection\n         * @param  {Mixed} elmts   Element or array of elements to add\n         * @return {Collective}    Collective collection\n         */\n        prepend: function (elmts) {\n            return this.add('unshift', elmts);\n        },\n\n        /**\n         * Add elements before an element of the collection matching search criteria\n         * @param  {Object} query  Object of criteria\n         * @param  {Mixed}  elmts  Element or array of elements to add\n         * @return {Mixed}         Collective collection\n         */\n        before: function (query, elmts) {\n            return this.add('splice', elmts, this.index(query));\n        },\n\n        /**\n         * Add elements after an element of the collection matching search criteria\n         * @param  {Object} query   Object of criteria\n         * @param  {Mixed}  elmts   Element or array of elements to add\n         * @return {Collective}     Collective collection\n         */\n        after: function (query, elmts) {\n            return this.add('splice', elmts, this.index(query) + 1);\n        },\n\n        /**\n         * Update the elements of the collection matching the search criteria\n         * @param  {Mixed}   queries    Object or array of objects of criteria\n         * @param  {Object}  newData    Object of data to update\n         * @param  {boolean} [replace]  Replace/Merge mode\n         * @return {Collective}         Collective collection\n         */\n        update: function (queries, newData, replace) {\n            var self = this,\n                data = this.collection.slice(),\n                updated = [];\n\n            //  If no query, update all the elements in the collection\n            if (!newData || newData === true) {\n                newData = queries;\n\n                this.collection.forEach(function (elmt, index) {\n                    self.update(index, newData, replace);\n                });\n            // Update the query selected elements\n            } else {\n                this.where(queries, { indexes: true }).forEach(function (index) {\n                    if (replace) {\n                        data[index] = newData;\n                    } else {\n                        Collective.extend(data[index], newData);\n                    }\n\n                    updated.push(data[index]);\n                });\n            }\n\n            var clone = this.clone(data);\n\n            if (updated.length) {\n                this.trigger('update', updated, clone);\n            }\n\n            return clone;\n        },\n\n        /**\n         * Replace the elements of the collection matching the search criteria\n         * @param  {Mixed}   queries    Object or array of objects of criteria\n         * @param  {Object}  newData    Object of data to update\n         * @return {Collective}         Collective collection\n         */\n        replace: function (queries, newData) {\n            return this.update(queries, newData, true);\n        },\n\n        /**\n         * Get a collection without the elements matching the search criteria\n         * @param  {Mixed}  queries   Object or array of objects of criteria\n         * @return {Collective}       Collective collection\n         */\n        remove: function (queries) {\n            var removed = this.where(queries).all(),\n                clone   = this.where(queries, { exclude: true });\n\n            if (removed.length) {\n                this.trigger('remove', removed, clone);\n            }\n\n            return clone;\n        },\n\n        /**\n         * Add an event callback when collection changes\n         * @param  {String}   event     Name of the event [ change, add, remove, fields, update]\n         * @param  {Function} callback  Function to call\n         * @return {Collective}         Collective collection\n         */\n        on: function (event, callback) {\n            this.events[event] = this.events[event] || [];\n            this.events[event].push(callback);\n\n            return this;\n        },\n\n        /**\n         * Remove an event callback\n         * @param  {String}   event     Name of the event [ change, add, remove, fields, update]\n         * @param  {Function} callback  Function to remove\n         * @return {Collective}         Collective collection\n         */\n        off: function (event, callback) {\n            this.events[event] = (this.events[event] || []).filter(function (value) {\n                return value !== callback;\n            });\n\n            return this;\n        },\n\n        /**\n         * Trigger the event callbacks\n         * @param  {String} event     Name of the event to trigger\n         * @param  {Mixed}  data      Data to pass to the called function\n         * @param  {Object} clone     Context for function call\n         * @return {Collective}       Collective collection\n         */\n        trigger: function (event, data, context) {\n            var callbacks1 = this.events.change || [], // Change event\n                callbacks2 = this.events[event] || [], // X event\n                callbacks  = callbacks1.concat(callbacks2);\n\n            context = context || this;\n\n            callbacks.forEach(function (callback) {\n                callback.call(context, data, event);\n            });\n\n            return context;\n        },\n\n        /**\n         * Clone a Collective collection\n         * @param  {Array} data     Array of elements to copy in the new collection\n         * @return {Collective}     Collective collection\n         */\n        clone: function (data) {\n            var copy = Object.create(this);\n            copy.collection = data ? data.slice() : this.collection.slice();\n            copy.length = copy.collection.length;\n\n            return copy;\n        },\n\n        /**\n         * Transfer values to a new element structure\n         * @param  {Object} mapping    Object of properties to transfer\n         * @return {Collective}        Collective collection\n         */\n        transfer: function (mapping) {\n            var data = [];\n\n            function mapIt (mapping, elmt) {\n                var buffer = {};\n\n                Object.keys(mapping).forEach(function (key) {\n                    var shortKey = key.split('.')[0],\n                        value;\n\n                    if (typeof mapping[key] === 'object') {\n                        value = mapIt(mapping[key], elmt);\n                    }\n                    else if (typeof mapping[key] === 'string') {\n                        value = Collective.path(elmt, mapping[key]);\n                    }\n\n                    buffer[shortKey] = Collective.object(key, value, true);\n                });\n\n                return buffer;\n            }\n\n            this.collection.forEach(function (elmt) {\n                data.push(mapIt(mapping, elmt));\n            });\n\n            var clone = this.clone(data);\n\n            if (!compare(data, this.collection)) {\n                this.trigger('update', data, clone);\n            }\n\n            return clone;\n        },\n\n        /**\n         * Split an array into chunks\n         * @param  {Number} number  Number of elements per chunk\n         * @return {Array}          Array of chunks\n         */\n        chunk: function (number) {\n            var i, total, chunks = [];\n\n            number = number || 5;\n            total = Math.ceil(this.collection.length / number);\n\n            for (i = 0; i < total; i++) {\n                chunks.push(this.collection.slice(i * number, i * number + number));\n            }\n\n            return chunks;\n        },\n\n\n        /**\n         * Get index of the first object of the collection matching search criteria\n         * @param  {Mixed} queries  Object or array of objects of criteria\n         * @return {Mixed}          Index of the object or false\n         */\n        index: function (queries) {\n            return this.where(queries, { indexes: true })[0];\n        },\n\n        /**\n         * Get index of the first found object in the collection similar to another object\n         * @param  {Object}  obj1      Object to compare\n         * @param  {Number}  [start]   Index to start with\n         * @param  {boolean} [last]    last index\n         * @return {Number}            Index found or -1\n         */\n        indexOf: function (elmt, start, last) {\n            var i, index = -1, len = this.collection.length;\n\n            start =  start || 0;\n\n            for (i = start; i < len; i++) {\n                var x, found = true,\n                    j = last ? len - i + start - 1 : i,\n                    elmt2     = this.collection[j],\n                    elmtKeys  = Object.keys(elmt),\n                    elmt2Keys = Object.keys(elmt2);\n\n                for (x = 0; x < elmtKeys.length; x++) {\n                    if (elmt[elmtKeys[x]] !== elmt2[elmtKeys[x]]) {\n                        found = false;\n                        break;\n                    }\n                }\n\n                for (x = 0; x < elmt2Keys.length; x++) {\n                    if (elmt[elmt2Keys[x]] !== elmt2[elmt2Keys[x]]) {\n                        found = false;\n                        break;\n                    }\n                }\n\n                if (found) {\n                    index = j;\n                    break;\n                }\n            }\n\n            return index;\n        },\n\n        /**\n         * Get index of the last found object in the collection similar to another object\n         * @param  {Object}  elmt      Element to compare\n         * @param  {Number}  [start]   Index to start with\n         * @return {Number}            Index found or -1\n         */\n        lastIndexOf: function (elmt, start) {\n            return this.indexOf(elmt, start, true);\n        },\n\n        /**\n         * Determine whether an array includes an element\n         * @param  {Object}  elmt      Element to compare\n         * @return {boolean}\n         */\n        includes: function (elmt) {\n            return this.indexOf(elmt) > -1;\n        },\n\n        /**\n         * Join an element property into a string.\n         * @param  {String} key       Property key\n         * @param  {String} separator Separator string\n         * @return {String}           Elements joined in a string\n         */\n        join: function (key, separator) {\n            return this.pluck(key).join(separator);\n        }\n    };\n\n    /**\n     * Proxy some native Array methods to modify the collection\n     * @return {Collective}     Collective collection\n     */\n    [ 'forEach', 'filter', 'slice', 'concat', 'map', 'reverse' ].forEach(function (fn) {\n        Collective.prototype[fn] = function () {\n            var data = this.collection[fn].apply(this.collection, [].slice.call(arguments));\n\n            return this.clone(data);\n        };\n    });\n\n    /**\n     * Proxy some native Array methods with native behaviors\n     * @return {Mixed}\n     */\n    [ 'pop', 'shift', 'push', 'unshift', 'every', 'some', 'reduce', 'splice', 'fill' ].forEach(function (fn) {\n        Collective.prototype[fn] = function () {\n            var value = this.collection[fn].apply(this.collection, [].slice.call(arguments));\n\n            this.length = this.collection.length;\n\n            return value;\n        };\n    });\n\n    /**\n     * Some Helpers\n     */\n\n    /**\n     * Return value2 if value1 is undefined\n     * @param  {Mixed} value1  Value to check\n     * @param  {Mixed} value2  Value to return\n     * @return {Mixed}         Value1 or Value2\n     */\n    function or (value1, value2) {\n        return value1 === undefined ? value2 : value1;\n    }\n\n    /**\n     * Return an Array with the value if not already an Array\n     * @param  {Mixed} elmts\n     * @return {Array}\n     */\n    function forceArray (elmts) {\n        return Array.isArray(elmts) ? elmts : [ elmts ];\n    }\n\n    /**\n     * Flatten and compare 2 values, Array or Object to check if similare\n     * @param  {Mixed} input1\n     * @param  {Mixed} input2\n     * @return {Boolean}\n     */\n    function compare (input1, input2) {\n        return JSON.stringify(input1) === JSON.stringify(input2);\n    }\n\n    /**\n     * Convert elements into a what Collective expects for its collection\n     * Throw an Error if the collection is not valid (Array of Objects)\n     * @param  {Mixed}   elmts       Array or OBject\n     * @param  {Boolean} mustBeArray Force to be an Array\n     * @return [Mixed]\n     */\n    function convert (elmts, mustBeArray) {\n        elmts = JSON.parse(JSON.stringify(elmts));\n        elmts = or(elmts.collection, elmts);\n        elmts = mustBeArray ? forceArray(elmts) : elmts;\n        isCollection(elmts, true);\n\n        return elmts;\n    }\n\n    /**\n     * Check if the collection is a valid Array of Objects\n     * @param  {Array}    collection     Collection\n     * @param  {Boolean}  throwError     Throw an error instead of returning false\n     * @return [{Boolean}]\n     */\n    function isCollection (collection, throwError) {\n        var isOk = forceArray(collection).every(function (element) {\n            return {}.toString.call(element) === \"[object Object]\";\n        });\n\n        if (!isOk && throwError) {\n            throw new Error('Collective only accepts Array/Objects.');\n        }\n\n        return isOk;\n    }\n\n    return Collective;\n});\n"]}